// Определения программных констант и переменных (параметры эффектов и т.п.)

// При запуске микроконтроллера выполняется инициализация всех параметров значениями, сохраненными в EEPROM (функция loadSettings() в eeprom.ino)
// При этом если флаг EEPROM_OK в первой строке файла eeprom.ino был изменен и не совпадает со считанными яз ячейки #0 значением -
// выполняется инициализация параметров значениями по умолчанию (функция loadSettings() в eeprom.ino, ветвь if (isInitialized) -> false )
// Заполните в этом блоки значения переменных желаемыми.

#define EEPROM_OK     0xA7       // Флаг, показывающий, что EEPROM инициализирована корректными данными 
#define EEPROM_MAX    4096       // Максимальный размер EEPROM доступный для использования
#define EFFECT_EEPROM  300       // начальная ячейка eeprom с параметрами эффектов, 5 байт на эффект
#define TEXT_EEPROM    800       // начальная ячейка eeprom с текстом бегущих строк

#define COLOR_ORDER    GRB       // порядок цветов на ленте. Если цвет отображается некорректно - меняйте. Начать можно с RGB
#define BRIGHTNESS      32       // стандартная максимальная яркость (0-255)

// ******************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ЭФФЕКТОВ *********************

// Список и порядок эффектов, передаваемый в приложение на смартфоне. Данный список попадает в комбобокс выбора, 
// чей индекс передается из приложения в контроллер матрицы для выбора, поэтому порядок должен соответствовать 
// списку эффектов, определенному выше
#if (USE_SD == 1)                      
#define EFFECT_LIST F("Часы,Лампа,Снегопад,Кубик,Радуга,Пейнтбол,Огонь,The Matrix,Шарики,Звездопад,Конфетти," \
                      "Цветной шум,Облака,Лава,Плазма,Радужные переливы,Павлин,Зебра,Шумящий лес,Морской прибой,Смена цвета," \
                      "Светлячки,Водоворот,Циклон,Мерцание,Северное сияние,Тени,Лабиринт,Змейка,Тетрис,Арканоид," \
                      "Палитра,Спектрум,Синусы,Вышиванка,Дождь,Камин,Водопад,Стрелки,Анимация,Погода,Жизнь,Узоры,Рассвет,SD-Карта")
#else
#define EFFECT_LIST F("Часы,Лампа,Снегопад,Кубик,Радуга,Пейнтбол,Огонь,The Matrix,Шарики,Звездопад,Конфетти," \
                      "Цветной шум,Облака,Лава,Плазма,Радужные переливы,Павлин,Зебра,Шумящий лес,Морской прибой,Смена цвета," \
                      "Светлячки,Водоворот,Циклон,Мерцание,Северное сияние,Тени,Лабиринт,Змейка,Тетрис,Арканоид," \
                      "Палитра,Спектрум,Синусы,Вышиванка,Дождь,Камин,Водопад,Стрелки,Анимация,Погода,Жизнь,Узоры,Рассвет")
#endif

// Список картинок, доступных для отрисовки в эффекте "Анимация".
// Нумерация - с 1 до MAX_IMAGE_NUM, список разделяется запятыми, позиция в списке соответствует индексу картинки для отрисовки
#define IMAGE_LIST F("Марио")

// Ниже представлен список эффектов, поддерживаемых прошивкой. Нумерация - сплошная от ID = 0 до ID = MAX_EFFECT
// Если какие-то эффекты вам не нужны - перенесите их в конец списка, исправьте нумерацию и поправьте MAX_EFFECT так,
// чтобы ненужные эффекты имели номера бОльшие MAX_EFFECT.
// Так как перебор эффектов идет от 0 до MAX_EFFECT-1, эффекты с номерами за этим диапазоном не будут отображаться.
// Также требуется исправить список эффектов EFFECT_LIST (см.выше) так, чтобы названия и порядок эффектов
// соответствовал списку, определенному ниже. Отключенные эффекты не должны писутствовать в EFFECT_LIST

// ID эффектов
#define MC_CLOCK                 0         // Режим отображения часов (когда "Ночные часы" или просто "Часы" на черном фоне, а не как оверлей поверх других эффектов
#define MC_FILL_COLOR            1
#define MC_SNOW                  2
#define MC_BALL                  3
#define MC_RAINBOW               4
#define MC_PAINTBALL             5
#define MC_FIRE                  6
#define MC_MATRIX                7
#define MC_BALLS                 8
#define MC_STARFALL              9
#define MC_SPARKLES             10
#define MC_NOISE_MADNESS        11
#define MC_NOISE_CLOUD          12
#define MC_NOISE_LAVA           13
#define MC_NOISE_PLASMA         14
#define MC_NOISE_RAINBOW        15
#define MC_NOISE_RAINBOW_STRIP  16
#define MC_NOISE_ZEBRA          17
#define MC_NOISE_FOREST         18
#define MC_NOISE_OCEAN          19
#define MC_COLORS               20
#define MC_LIGHTERS             21
#define MC_SWIRL                22
#define MC_CYCLON               23
#define MC_FLICKER              24
#define MC_PACIFICA             25
#define MC_SHADOWS              26
#define MC_MAZE                 27
#define MC_SNAKE                28
#define MC_TETRIS               29
#define MC_ARKANOID             30
#define MC_PALETTE              31
#define MC_ANALYZER             32
#define MC_PRIZMATA             33
#define MC_MUNCH                34
#define MC_RAIN                 35
#define MC_FIRE2                36
#define MC_WATERFALL            37
#define MC_ARROWS               38
#define MC_IMAGE                39
#define MC_WEATHER              40
#define MC_LIFE                 41
#define MC_PATTERNS             42
#define MC_DAWN_ALARM           43
#define MC_SDCARD               44

#if (USE_SD == 1)
#define MAX_EFFECT              45         // количество эффектов, определенных в прошивке
#else
#define MAX_EFFECT              44         // количество эффектов, определенных в прошивке
#endif

#define MAX_SPEC_EFFECT         11         // количество эффектов быстрого доступа определенных в прошивке -> 0..10
#define MAX_IMAGE_NUM            1         // Количество картинок для эффекта "Анимация", определенных в программе (файлы bitmap1.h, .. ,bitmapN.h)

// ---------------------------------
#define SPECIAL_EFFECTS_START  120         // Некоторые специальные "служебные" эффекты имеют код >= SPECIAL_EFFECTS_START
                                           // Внимание !!! - для идентификатора режима используется тип int8_t (-128..127, нужно значение -1), поэтому код режима не может быть больше 127 !!!
#define MC_DRAW                123         // Режим рисования картинки на телефоне
#define MC_LOADIMAGE           124         // Режим загрузки изображения с телефона
#define MC_TEXT                125         // Режим бегущей строки (для отображения IP адреса) - бегущая строка на черном фоне
#define MC_DAWN_ALARM_SPIRAL   126         // Специальный режим, вызывается из DEMO_DAWN_ALARM для ламп на круговой матрице - огонек по спирали
#define MC_DAWN_ALARM_SQUARE   127         // Специальный режим, вызывается из DEMO_DAWN_ALARM для плоских матриц - огонек по спирали на плоскости матрицы
// ---------------------------------

// *************************************************************************

enum  eModes   {NORMAL, COLOR, TEXT}   parseMode; // Текущий режим парсера
enum  eSources {NONE, BOTH, UDP, MQTT} cmdSource; // Источник команды; NONE - нет значения; BOTH - любой, UDP-клиент, MQTT-клиент

// ****************** ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ БУДИЛЬНИКА ********************

#if (USE_MP3 == 1)
// SD карточка в MP3 плеере (DFPlayer) содержит в корне две папки - "1" и "2"
// Папка "1" содержит MP3 файлы звуков, проигрываемых при наступлении события будильника
// Папка "2" содержит MP3 файлы звуков, проигрываемых при наступлении события рассвета
// DFPlayer не имеет возможности считывать имена файлов, только возможность получить количество файлов в папке.
// Команда на воспроизведение звука означает - играть файл с индексом (номером) N из папки M
// Номера файлов определяются таблицей размещения файлов SD-карты (FAT)  и формируются в порядке очереди записи файлов на чистую флэшку
// Так, файл записанный в папку первым получает номер 1, второй - 2 и так далее и ника не зависит от имен файлов
// Данные массивы содержат отображаемые в приложении имена звуков в порядке, соответствующем нумерации записанных в папки файлов.

// Список звуков для комбобокса "Звук рассвета" в приложении на смартфоне
#define ALARM_SOUND_LIST   F("One Step Over,In the Death Car,Труба зовет,Маяк,Mister Sandman,Шкатулка,Banana Phone")
// Список звуков для комбобокса "Звук рассвета" в приложении на смартфоне
#define DAWN_SOUND_LIST    F("Птицы,Гроза,Прибой,Дождь,Ручей,Мантра,La Petite Fille De La Mer")
// Список звуков для макроса {A} бегущей строки
#define NOTIFY_SOUND_LIST  F("Piece Of Сake,Swiftly,Pristine,Goes Without Saying,Inflicted,Eventually,Point Blank,Spring Board,To The Point,Serious Strike,Jingle Bells,Happy New Year,Christmas Bells,Door Knock,Alarm Signal,Viber Message,Viber Call,Text Message")

#endif

// ********************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ЧАСОВ **********************

#define MIN_BRIGHT_FOR_NIGHT 192          // Для цвета 0x020202 при 128 начинают гореть красные диоды, при 156 - синие, при 192 зеленые
                                          // То есть 192 - минимальная яркость при котором горят все три компоненты цвета 0x020202
#define D_CLOCK_SPEED 100                 // скорость перемещения эффекта часов по умолчанию (мс)
#define D_CLOCK_SPEED_MIN 2
#define D_CLOCK_SPEED_MAX 255

byte CLOCK_SIZE = 0;                      // Размер горизонтальных часов: 0 - авто; 1 - цифры 3x5; 2 - цифры 5х7
byte CLOCK_ORIENT = 0;                    // Ориентация отображения часов: 0 горизонтальные, 1 вертикальные (только для режима часов с цифрами 3х5; Часы шрифтом 5x7 всегда горизонтальные
byte CLOCK_MOVE_DIVIDER = 3;              // Делитель такта таймера эффектов для движения часов оверлея (режим прокручивания часов по горизонтали)
byte CLOCK_MOVE_CNT = CLOCK_MOVE_DIVIDER; // Текущее значения счетчика сдвига 

byte clockScrollSpeed = D_CLOCK_SPEED;      // Скорость прокрутки часов
byte c_size = 0;                            // тип часов: 0 - авто; 1 - шрифт 3x5; 2 - шрифт 5х7; вычисляется в зависимости от настроек и параметров матрицы 
bool allow_two_row = false;                 // высота матрицы позволяет размещать календарь и часы с температурой в две строки  

// Позиции отображения часов, календаря, погоды; 
// Вычисляется в зависимости от выбранного шрифта часов 3x5 или 5x7, вертикальные/горизонтальные
byte   CALENDAR_X;                          // Позиция вывода календаря по X
byte   CALENDAR_Y;                          // Позиция вывода календаря по Y
byte   CLOCK_X        ;                     // Позиция вывода часов по X
byte   CLOCK_Y;                             // Позиция вывода часов по Y
int8_t CLOCK_WX;                            // Позиция вывода погоды по X в малых часах / Реальная ширина отрисованных часов в больших часах
int8_t CLOCK_WY;                            // Позиция вывода погоды по Y

byte   CALENDAR_W;                          // Ширина вывода календаря
byte   CALENDAR_H;                          // Высота вывода календаря по Y
byte   CLOCK_W        ;                     // Ширина вывода часов по X
byte   CLOCK_H;                             // Высота вывода часов по Y
byte   CLOCK_WW;                            // Ширина вывода погоды по X
byte   CLOCK_WH;                            // Высота вывода погоды по Y

int8_t CLOCK_XC    = 0;                     // Текущая позиция часов оверлея по оси Х с учетом скроллинга
int8_t CALENDAR_XC = 0;                     // Текущая позиция календаря оверлея по оси Х 
int8_t CLOCK_FX    = 0;                     // Реальная X позиция отрисовки первой цифры блока часов и температуры
int8_t CLOCK_LX    = 0;                     // Реальная X позиция отрисовки последнй цифры часов - температура юудет выводиться от этой позиции влево, чтобы выровнять температуру по правому краю часов

// Часы могут отображаться: 
// - вертикальные при высоте матрицы >= 11 и ширине >= 7; 
// - горизонтальные при ширене матрицы >= 15 и высоте >= 5
//   минимальная ширина горизонтальных часов - 15 символов, т.к если большие часы не помещаются по ширине - автоматически используются маленькие часы
bool   allowVertical   = WIDTH >= 7  && HEIGHT >= 11;
bool   allowHorizontal = WIDTH >= 15 && HEIGHT >= 5;

byte   COLOR_MODE = 0;                      // Режим цвета часов
                                            //  0 - монохром
                                            //  1 - радужная смена (каждая цифра)
                                            //  2 - радужная смена (часы, точки, минуты)
                                            //  3 - заданные цвета (часы, точки, минуты) - HOUR_COLOR, DOT_COLOR, MIN_COLOR в clock.ino

byte   nightClockColor = 0;                 // Цвет ночных часов: 0 - R; 1 - G; 2 - B; 3 - C; 4 - M; 5 - Y; 6 - W;
byte   nightClockBrightness = 2;            // Яркость отображения ночных часов
bool   needTurnOffClock = false;            // Выключать индикатор часов TM1637 при выключении устройства (true); если False - при отключении панели индикатор TM1637 продолжает показывать текущее время

bool   showWeatherInClock = true;           // Показывать текущую температуру при отображении малых (неподвижных) часов
bool   showDateInClock = true;              // Показывать дату при отображении часов
byte   showDateDuration = 2;                // на 2 секунды
byte   showDateInterval = 240;              // через каждые 240 секунд
bool   showDateState = false;               // false - отображаются часы; true - отображается дата
bool   showWeatherState = false;            // false - отображаются часы; true - отображается температура в больших часах
long   showDateStateLastChange = 0;         // Время, когда отображение часов сменилось на отображение календаря и наоборот

int8_t  hrs = 0, mins = 0;                  // Для получения текущего времени. Инициализировано как 01.01.1970 00:00
int8_t  secs = 0, aday = 1, amnth = 1;
int16_t ayear = 1970;
bool    dotFlag;                            // флаг: в часах рисуется точки 

// ************************ НАСТРОЙКИ БЕГУЩЕЙ СТРОКИ ***********************

#define D_TEXT_SPEED 100                    // скорость перемещения эффекта часов по умолчанию (мс)
#define D_TEXT_SPEED_MIN 2
#define D_TEXT_SPEED_MAX 255

#define MIRR_V 0                            // отразить текст по вертикали (0 / 1)
#define MIRR_H 0                            // отразить текст по горизонтали (0 / 1)

#define LET_WIDTH 5                         // ширина буквы шрифта
#define LET_HEIGHT 8                        // высота буквы шрифта
#define SPACE 1                             // пробел между буквами

byte textScrollSpeed = D_TEXT_SPEED;        // Скорость прокрутки оверлея бегущей строки

uint16_t TEXT_INTERVAL = 90;                // Интервал (время в секундах) между отображением строк
                                            // следующая бегущая строка будет отображена через указанное кол-во секунд
                                            // 0 - отключено, следующая строка отображается после завершения текущей
                                         
byte    COLOR_TEXT_MODE = 0;                // Режим цвета текста бегущей строки и самой бегущей строки
                                            //  0 - монохром
                                            //  1 - радужная смена (каждая цифра)
                                            //  2 - каждая цифра свой цвет
                                         
// --- Параметры отображения текущей бегущей строки
int16_t  textShowTime = -1;                 // Если больше нуля - сколько времени отображать бегущую строку в секундах; Если 0 - используется textShowCount; В самой строке спец-макросом может быть указано кол-во секунд
byte     textShowCount = 1;                 // Сколько раз прокручивать текст бегущей строки поверх эффектов; По умолчанию - 1; В самой строке спец-макросом может быть указано число 
byte     textCurrentCount = 0;              // Сколько раз текст очередной бегущей строки поверх эффектов уже показан
boolean  useSpecialTextColor = false;       // В текущей бегущей строке был задан цвет, которым она должна отображаться
uint32_t specialTextColor = 0xffffff;       // Цвет отображения бегущей строки, может быть указан макросом в строке. Если не указан - используются глобальные настройки цвета бегущей строки
boolean  useSpecialBackColor = false;       // В текущей бегущей строке был задан цвет фона, на котором она должна отображаться
uint32_t specialBackColor = 0x000000;       // Цвет фона отображения бегущей строки, может быть указан макросом в строке. Если не указан - наложение на текущий эффект
int8_t   specialTextEffect = -1;            // Эффект, который нужно включить при начале отображения строки текста, может быть указан макросом в строке.
int8_t   specialTextEffectParam = -1;       // Параметр для эффекта (см. выше). Например эффект MC_SDCARD имеет более 40 подэффектов. Номер подэффекта хранится в этой переменной, извлекается из макроса {E}
int8_t   saveEffectBeforeText = -1;         // Если указан эффект на котором отображать строку, сохранить текущий эфф тут, чтобы по завершению строки восстановить его
int8_t   currentTextLineIdx = -1;           // Какая строка из массива строк показывается в текущий момент
int8_t   nextTextLineIdx = -1;              // Какую следующую строку показыват, может быть указан макросом в строке. Если указан - интервал отображения игнорируется, строка показывается сразу
boolean  textHasDateTime = false;           // Строка содержит макрос отображения текущего времени - ее нужно пересчитывать каждый раз при отрисовке; Если макроса времени нет - рассчитать текст строки один раз на этапе инициализации
boolean  textHasMultiColor = false;         // Строка содержит несколько (до 6) макросов, задающих цвет строки
String   currentText  = "";                 // Текст текущей отображаемой строки
boolean  ignoreTextOverlaySettingforEffect = false; // Показывать бегущую строку для эффекта, даже если настройки эффекта это запрещают; В строке может быть указано, какую строку показывать следующей - ее надо показывать даже если настройки текущего эффекта это запрещают
int8_t   sequenceIdx = -1;                  // Если нулевая строка массива содержит последовательность отображеня строк (начинается с # или имеет значение ##) - указывает на позицию какой будет следующая отображаемая строка
int8_t   editIdx = -1;                      // Индекс строки, передаваемой в телефон на запрос строки по индексу
uint16_t crc = 0;                           // Контрольная сумма загруженного массива строк. Рассчитывается при загрузке, проверяется перед сохранением 
int16_t  memoryAvail = 0;                   // Сколько памяти осталось под хранение строк; Устанавливается при загрузке / сохранении массива строк
#define  MAX_COLORS 12                      // сколько макросов цвета может содержать строка
int16_t  textColorPos[MAX_COLORS+1];        // Позиции начала цвета в строке
uint32_t textColor[MAX_COLORS+1];           // Цвета в строке

// --- 

unsigned long textStartTime = 0;            // Время начала отображения текущей бегущей строки
unsigned long textLastTime = 0;             // Время завершения отображения последней показанной бегущей строки
unsigned long textLastSend = 0;             // Время последней отправки очередной строки списка строк в телефон
unsigned long textAllowBegin = 0;           // Для строк с макросом {S} - время начала допустимого интервала отображения unixTime
unsigned long textAllowEnd = 4294967295;    // Для строк с макросом {S} - время конца допустимого интервала отображения unixTime

boolean loadingTextFlag = false;            // Флаг инициализации показа строки в режиме MC_TEXT (показ IP адреса); для новой строки оверлейного текста используется специальный вызов prepareNextText() в custom.ino
boolean showTextNow = false;                // флаг: что в настоящий момент нужно отображать оверлеем: true - оверлей бегущей строки; false - оверлей часов;
boolean fullTextFlag = false;               // флаг: текст бегущей строки показан полностью (строка убежала)
boolean gameOverFlag = false;               // флаг: демо-игра завершена

String  textLines[36];                      // Массив строк для отображения 0..9A..Z; 

// --- 

typedef struct  {                           // Структура описателя событий постоянного контроля
  time_t moment;                            // unixtime - ближайший момент времени наступления события
  uint32_t before;                          // за сколько секунд до события начинать отображать строку
  uint32_t after;                           // сколько секунд после наступления события отображать строку-заместитель
  uint8_t  index_b;                         // индекс в массиве строк textLines отображаемой строки ДО события, привязанной к этому событию
  int8_t   index_a;                         // индекс в массиве строк textLines отображаемой строки ПОСЛЕ события, привязанной к этому событию (-1 если строки замены не указано)
} Moment;

#define MOMENTS_NUM  6                      // максимальное количество отслеживаемых событий для строк, содержащих макрос {P}
Moment moments[MOMENTS_NUM];                // массив с моментами времени событий для бегущих строк с макросом {P}
boolean moment_active = false;              // В текущий момент происходит отображение строки, привязанной к отслеживаемому событию.
int8_t momentIdx = -1;                      // Индекс строки в массиве moments для активного текущего непрерывно отслеживаемого события
int8_t momentTextIdx = -1;                  // Индекс строки в массиве textLines для активного текущего непрерывно отслеживаемого события
unsigned long textCheckTime = 0;            // Время контроля списка событий непрерывного отслеживания

// *************************** ПОДКЛЮЧЕНИЕ К СЕТИ **************************

// Внимание!!! Если вы меняете эти значения ПОСЛЕ того, как прошивка уже хотя бы раз была загружена в плату и выполнялась,
// чтобы изменения вступили в силу нужно также изменить значение константы EEPROM_OK в первой строке в файле eeprom.ino 

#define DEFAULT_NTP_SERVER "ru.pool.ntp.org" // NTP сервер по умолчанию "time.nist.gov"
#define DEFAULT_AP_NAME "PanelAP"           // Имя точки доступа по умолчанию 
#define DEFAULT_AP_PASS "12341234"          // Пароль точки доступа по умолчанию

#ifndef NETWORK_SSID
#define NETWORK_SSID ""                     // Имя WiFi сети
#endif

#ifndef NETWORK_PASS
#define NETWORK_PASS ""                     // Пароль для подключения к WiFi сети
#endif

#ifndef DEFAULT_IP
#define DEFAULT_IP {192, 168, 0, 100}       // Сетевой адрес устройства по умолчанию
#endif

// ---------------------------------------------------------------

WiFiUDP udp;                                // Объект транспорта сетевых пакетов
                                            // к длине +1 байт на \0 - терминальный символ. Это буферы для загрузки имен/пароля из EEPROM. Значения задаются в define выше
char   apName[11] = DEFAULT_AP_NAME;        // Имя сети в режиме точки доступа
char   apPass[17] = DEFAULT_AP_PASS;        // Пароль подключения к точке доступа
char   ssid[25]   = NETWORK_SSID;           // SSID (имя) вашего роутера (конфигурируется подключением через точку доступа и сохранением в EEPROM)
char   pass[17]   = NETWORK_PASS;           // пароль роутера
byte   IP_STA[]   = DEFAULT_IP;             // Статический адрес в локальной сети WiFi по умолчанию при первом запуске. Потом - загружается из настроек, сохраненных в EEPROM
unsigned int localPort = 2390;              // локальный порт на котором слушаются входящие команды управления от приложения на смартфоне, передаваемые через локальную сеть

// ------------------------ MQTT parameters --------------------
#if (USE_MQTT == 1)

WiFiClient m_client;                             // Объект для работы с удалёнными хостами - соединение с MQTT-сервером
PubSubClient mqtt(m_client);                     // Объект соединения с MQTT сервером

String mqtt_client_name = "";                    // Имя для регистрации клиента на сервере MQTT

// Внимание!!! Если вы меняете эти значения ПОСЛЕ того, как прошивка уже хотя бы раз была загружена в плату и выполнялась,
// чтобы изменения вступили в силу нужно также изменить значение константы EEPROM_OK в строке 8 этого файла

#ifndef DEFAULT_MQTT_SERVER
#define DEFAULT_MQTT_SERVER "mqtt.by"            // MQTT сервер
#endif

#ifndef DEFAULT_MQTT_USER
#define DEFAULT_MQTT_USER   ""                   // Имя mqtt-пользователя    (укажите имя пользователя для вашего соединения)
#endif

#ifndef DEFAULT_MQTT_PASS
#define DEFAULT_MQTT_PASS   ""                   // Пароль mqtt-пользователя (укажите пароль вашего соединения)
#endif

#ifndef DEFAULT_MQTT_PORT
#define DEFAULT_MQTT_PORT   1883                 // Порт mqtt-соединения
#endif

#ifndef DEFAULT_MQTT_PREFIX
#define DEFAULT_MQTT_PREFIX "af7cd12a"           // Префикс топика сообщения уникальный для вашего устройства
#endif

// Код работы с MQTT-каналом ориентирован на использование MQTT-брокера mqtt.4api.ru
// Для управления и отладки можно использовать одну из следующих консолей: client.mqtt.4api.ru, hivemq.com/demos/websocket-client

#define  TOPIC_CMD      "cmd"                    // Топик - получение команды управления от клиента
#define  TOPIC_DTA      "dta"                    // Топик - отправка запрошенных данных клиенту
#define  TOPIC_ERR      "err"                    // Топик - отправка уведомлений об ошибке клиенту
#define  TOPIC_STA      "sta"                    // Топик - отправка уведомления о (ре)старте микроконтроллера
#define  TOPIC_ALM      "alm"                    // Топик - отправка клиенту сообщений о событиях будильника
#define  TOPIC_AMD      "amd"                    // Топик - отправка клиенту сообщений о событиях авторежимов по времени
#define  TOPIC_WTR      "wtr"                    // Топик - отправка клиенту сообщений о событиях погоды
#define  TOPIC_TME      "tme"                    // Топик - отправка клиенту сообщений о событиях времени
#define  TOPIC_PWR      "pwr"                    // Топик - отправка клиенту сообщений о включении/выключении устройства
#define  TOPIC_SDC      "sdc"                    // Топик - отправка клиенту сообщений о событиях SD-карты
#define  TOPIC_TXT      "txt"                    // Топик - отправка клиенту сообщений о событиях бегущей строки
#define  TOPIC_STT      "stt"                    // Топик - отправка клиенту сообщений о текущем статусе параметров устройства - основной набор параеметров (пакет)

#define  MQTT_CONNECT_TIMEOUT 1000               // Таймаут попытки установить соединение с MQTT сервером
#define  MQTT_RECONNECT_PERIOD 300000            // Интервал между попытками соединения с MQTT сервером, если соединение не установилось из за неответа сервера по таймауту

bool     useMQTT = true;                         // Использовать канал управления через MQTT - флаг намерения    // При отключении из приложения set_useMQTT(false) устанавлифается соответствующее состояние (параметр QA), состояние 'намерение отключить MQTT'
bool     stopMQTT = false;                       // Использовать канал управления через MQTT - флаг результата   // которое должно быть отправлено на MQTT-сервер, значит реально состояние 'MQTT остановлен' - только после отправки флага QA на сервер
char     mqtt_server[25] = "";                   // Имя сервера MQTT
char     mqtt_user[15]   = "";                   // Логин от сервера
char     mqtt_pass[15]   = "";                   // Пароль от сервера
char     mqtt_prefix[31] = "";                   // Префикс топика сообщения
uint16_t mqtt_port       = DEFAULT_MQTT_PORT;    // Порт для подключения к серверу MQTT

// Выделение места под массив команд, поступающих от MQTT-сервера
// Callback на поступление команды от MQTT сервера происходит асинхронно, и если предыдущая
// команда еще не обработалась - происходит новый вызов обработчика команд, который не реентерабелен -
// это приводит к краху приложения. Чтобы избежать этого поступающие команды будем складывать в очередь 
// и выполнять их в основном цикле программы
#define  QSIZE_IN 8                         // размер очереди команд от MQTT
#define  QSIZE_OUT 96                       // размер очереди исходящих сообщений MQTT
String   cmdQueue[QSIZE_IN];                // Кольцевой буфер очереди полученных команд от MQTT
String   tpcQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (topic)
String   outQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (message)
bool     rtnQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (retain)
byte     queueWriteIdx = 0;                 // позиция записи в очередь обработки полученных команд
byte     queueReadIdx = 0;                  // позиция чтения из очереди обработки полученных команд
byte     queueLength = 0;                   // количество команд в очереди обработки полученных команд
byte     outQueueWriteIdx = 0;              // позиция записи в очередь отправки MQTT сообщений
byte     outQueueReadIdx = 0;               // позиция чтения из очереди отправки MQTT сообщений
byte     outQueueLength = 0;                // количество команд в очереди отправки MQTT сообщений

String   last_mqtt_server = "";
uint16_t last_mqtt_port = 0;

String   changed_keys = "";                 // Строка, содержащая список измененных параметров, чье состояние требуется отправить серверу
bool     mqtt_connecting = false;           // Выполняется подключение к MQTT (еще не установлено)
bool     mqtt_topic_subscribed = false;     // Подписка на топик команд выполнена
byte     mqtt_conn_cnt = 0;                 // Счетчик попыток подключения для форматирования вывода
unsigned long mqtt_conn_last;               // Время последней попытки подключения к MQTT-серверу
uint16_t upTimeSendInterval = 0;            // Интервал отправки uptime в секундах, 0 если не нужно отправлять
unsigned long uptime_send_last;             // Время последней отправки uptime к MQTT-серверу по инициативе устройства
unsigned long nextMqttConnectTime;          // При недоступности MQTT ервера определяет время следующей попытки соединения
#endif

// ---------------------------------------------------------------

bool   useSoftAP = false;                   // использовать режим точки доступа
bool   wifi_connected = false;              // true - подключение к wifi сети выполнена  
bool   ap_connected = false;                // true - работаем в режиме точки доступа;
bool   wifi_print_ip = false;               // Включен режим отображения текущего IP на индикаторе TM1637
bool   wifi_print_ip_text = false;          // Включен режим отображения текущего IP на матрице
byte   wifi_print_idx = 0;                  // Индекс отображаемой на индикаторе TM1637 тетрады IP адреса
String wifi_current_ip = "";                // Отображаемый в бегущей строке IP адрес лампы

// **************** СИНХРОНИЗАЦИЯ ЧАСОВ ЧЕРЕЗ ИНТЕРНЕТ *******************

IPAddress timeServerIP;
#define NTP_PACKET_SIZE 48                  // NTP время - в первых 48 байтах сообщения
uint16_t SYNC_TIME_PERIOD = 60;             // Период синхронизации в минутах по умолчанию
byte packetBuffer[NTP_PACKET_SIZE];         // буфер для хранения входящих и исходящих пакетов NTP

int8_t timeZoneOffset = 7;                  // смещение часового пояса от UTC
long   ntp_t = 0;                           // Время, прошедшее с запроса данных с NTP-сервера (таймаут)
byte   ntp_cnt = 0;                         // Счетчик попыток получить данные от сервера
bool   init_time = false;                   // Флаг false - время не инициализировано; true - время инициализировано
bool   refresh_time = true;                 // Флаг true - пришло время выполнить синхронизацию часов с сервером NTP
bool   useNtp = true;                       // Использовать синхронизацию времени с NTP-сервером
bool   getNtpInProgress = false;            // Запрос времени с NTP сервера в процессе выполнения
char   ntpServerName[31] = "";              // Используемый сервер NTP

// *************************** Yandex.Погода *****************************

WiFiClient w_client;                        // Объект для работы с удалёнными хостами - соединение с сервером погоды
boolean  init_weather = false;              // Флаг: true - погода получена; false - погода не получена / не актуальна

#if (USE_WEATHER == 1)
uint8_t  useWeather = 1;                    // Использовать получение текущей погоды с погодного сервера 0 - не использовать; 1 - Yandex; 2 - OpenWeatherMap
uint32_t regionID = 62;                     // Код региона по Yandex
uint32_t regionID2 = 1502026;               // Код региона по OpenWeatherMap
String   skyColor;                          // Рекомендованный цвет фона погоды
String   weather;                           // Состояние - "Ясно", "Облачно", "Дождь" и т.д.
String   dayTime;                           // "Темное время суток" / "Светлое время суток"
bool     isNight;                           // день / ночь
int8_t   temperature;                       // Текущая температура 
int16_t  weather_code;                      // код погодных условий для OpenWeatherMap

String   icon;                              // код иконки, содержит зашифрованный статус погодных условий 
long     weather_t = 0;                     // Время, прошедшее с запроса данных с сервера погоды (таймаут)
byte     weather_cnt = 0;                   // Счетчик попыток получить данные от сервера
unsigned long weather_time;                 // Время последнего получения погоды;
byte     weatherActualityDuration = 3;      // Какой период времени в часах после получения погоды считать ее актуальной (на случай, если сервер перестал отвечать)
uint16_t SYNC_WEATHER_PERIOD = 15;          // Период обновления информации о текущей погоде в минутах по умолчанию
byte     refresh_weather = true;            // Флаг: пришло время очередного получения погоды с сервера
bool     getWeatherInProgress = false;      // Запрос погоды сервера в процессе выполнения
bool     weather_ok = true;                 // Погода получена

// API-идентификатор сервиса получения погоды - смотрите раздел Wiki - Настройка получения информации о погоде
// https://github.com/vvip-68/GyverPanelWiFi/wiki/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE-%D0%BF%D0%BE%D0%B3%D0%BE%D0%B4%D0%B5
#ifndef WEATHER_API_KEY
#define WEATHER_API_KEY "6a4ba421859c9f4166697758b68d889b"
#endif
#endif

boolean  useTemperatureColor = true;        // Для дневных часов: true - выводить температуру специальным цветом, в зависимости от значения температуры; 0 - не использовать градации цвета
boolean  useTemperatureColorNight = false;  // Для ночных часов:  true - выводить температуру специальным цветом, в зависимости от значения температуры; 0 - не использовать градации цвета

#define  cold_less_30 "#3300FF"             // -39..-30
#define  cold_29_20   "#0000FF"             // -29..-20
#define  cold_19_10   "#0077FF"             // -19..-10
#define  cold_9_4     "#00FFFF"             //  -9..-4
#define  zero_3_3     "#808080"             //  -3..+3
#define  hot_4_9      "#AA5511"             //  +4..+9
#define  hot_10_19    "#773300"             // +10..+19
#define  hot_20_29    "#A01F03"             // +20..+29
#define  hot_30_great "#FF0000"             // +30..+39

#define  night_blue_temperature  CRGB(0x000002)  // цвет температуры в ночных часах - отрицательные (синий)
#define  night_red_temperature   CRGB(0x020000)  // цвет температуры в ночных часах - положительные (красный)
#define  night_white_temperature CRGB(0x020202)  // цвет температуры в ночных часах - околонулевые  (-3..+3)

// *********************** ДЛЯ БУДИЛЬНИКА-РАССВЕТ ************************

bool   isAlarming = false;                  // Сработал будильник "рассвет"
bool   isPlayAlarmSound = false;            // Сработал настоящий будильник - играется звук будильника
bool   isAlarmStopped = false;              // Сработавший будильник "рассвет" остановлен пользователем

byte   alarmWeekDay = 0;                    // Битовая маска дней недели будильника
byte   alarmDuration = 1;                   // Проигрывать звук будильнике N минут после срабатывания (по окончанию рассвета)

byte   alarmHour[7]   = {0,0,0,0,0,0,0};    // Часы времени срабатывания будильника по дням недели
byte   alarmMinute[7] = {0,0,0,0,0,0,0};    // Минуты времени срабатывания будильника по дням недели

int8_t dawnHour = 0;                        // Часы времени начала рассвета
int8_t dawnMinute = 0;                      // Минуты времени начала рассвета
byte   dawnWeekDay = 0;                     // День недели времени начала рассвета (0 - выключено, 1..7 - пн..вс)
byte   dawnDuration = 10;                   // Продолжительность "рассвета" по настройкам в минутах
byte   realDawnDuration = 0;                // Продолжительность "рассвета" по вычисленному времени срабатывания будильника
byte   alarmEffect = MC_DAWN_ALARM;         // Какой эффект используется для будильника "рассвет". Могут быть обычные эффекты - их яркость просто будет постепенно увеличиваться

// **************************** MP3 ПЛЕЕР *****************************

bool isDfPlayerOk = false;                  // MP3-Player корректно инициализирован и готов к использованию

#if (USE_MP3 == 1)
SoftwareSerial mp3Serial;
DFRobotDFPlayerMini dfPlayer; 
int16_t  alarmSoundsCount = 0;              // Кол-во файлов звуков в папке '01' на SD-карте
int16_t  dawnSoundsCount = 0;               // Кол-во файлов звуков в папке '02' на SD-карте
int16_t  noteSoundsCount = 0;               // Кол-во файлов звуков в папке '03' на SD-карте
byte     soundFolder = 0;                   // Текущая используемая папка со звуками 
byte     soundFile = 0;                     // Текущий используемый файл звука в папке
int8_t   fadeSoundDirection = 1;            // направление изменения громкости звука: 1 - увеличение; -1 - уменьшение
byte     fadeSoundStepCounter = 0;          // счетчик шагов изменения громкости, которое осталось сделать
bool     useAlarmSound = false;             // Использовать звуки в будильнике
int8_t   alarmSound = 0;                    // Звук будильника - номер файла в папке SD:/01 [-1 не использовать; 0 - случайный; 1..N] номер файла
int8_t   dawnSound = 0;                     // Звук рассвета   - номер файла в папке SD:/02 [-1 не использовать; 0 - случайный; 1..N] номер файла
int8_t   runTextSound = -1;                 // Номер звука в папке SD://03 на sd-карте, который воспроизводится вместе с отображением бегущей строки
bool     runTextSoundRepeat = false;        // Флаг - повторять в циклеж false - играть один раз; true - зацикливать
byte     maxAlarmVolume = 30;               // Максимальная громкость будильника (1..30)
#endif

// ************************* КНОПКА УПРАВЛЕНИЯ *************************

#if (BUTTON_TYPE == 0)
  GButton butt(PIN_BTN, LOW_PULL, NORM_OPEN);    // Для сенсорной кнопки
#else
  GButton butt(PIN_BTN, HIGH_PULL, NORM_OPEN);   // Для обычной кнопки
#endif

bool     isButtonHold = false;              // Кнопка нажата и удерживается
byte     bCounter = 0;                      // Счетчик нажатия на кнопку

// ************************** Дисплей TM1637 **************************

#if (USE_TM1637 == 1)
TM1637Display display(CLK, DIO);
bool     aDirection = true;                 // Направление счетчика изменения яркости, отображаемом на индикаторе при регулировке
byte     aCounter = 0;                      // Текущая яркость индикатора при плавном изменении яркости
uint32_t fade_time;                         // Для плавного изменения яркости индикатора при сработавшем будильнике
#endif

// ******************** ВКЛЮЧЕНИЕ РЕЖИМОВ ПО ВРЕМЕНИ *********************

bool     AM1_running = false;               // Режим 1 по времени - работает
byte     AM1_hour = 0;                      // Режим 1 по времени - часы
byte     AM1_minute = 0;                    // Режим 1 по времени - минуты
int8_t   AM1_effect_id = -3;                // Режим 1 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM2_running = false;               // Режим 2 по времени - работает
byte     AM2_hour = 0;                      // Режим 2 по времени - часы
byte     AM2_minute = 0;                    // Режим 2 по времени - минуты
int8_t   AM2_effect_id = -3;                // Режим 2 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM3_running = false;               // Режим 3 по времени - работает
byte     AM3_hour = 0;                      // Режим 3 по времени - часы
byte     AM3_minute = 0;                    // Режим 3 по времени - минуты
int8_t   AM3_effect_id = -3;                // Режим 3 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM4_running = false;               // Режим 4 по времени - работает
byte     AM4_hour = 0;                      // Режим 4 по времени - часы
byte     AM4_minute = 0;                    // Режим 4 по времени - минуты
int8_t   AM4_effect_id = -3;                // Режим 4 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dawn_running = false;              // Режим по времени "Рассвет" - работает
byte     dawn_hour = 0;                     // Режим по времени "Рассвет" - часы
byte     dawn_minute = 0;                   // Режим по времени "Рассвет" - минуты
int8_t   dawn_effect_id = -3;               // Режим по времени "Рассвет" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dusk_running = false;              // Режим по времени "Закат" - работает
byte     dusk_hour = 0;                     // Режим по времени "Закат" - часы
byte     dusk_minute = 0;                   // Режим по времени "Закат" - минуты
int8_t   dusk_effect_id = -3;               // Режим по времени "Закат" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST

// ************************* РАБОТА С SD КАРТОЙ *************************

#if (USE_SD == 1)

#define MAX_FILES 126                       //  больше нельзя - переполнение индекса массива для типа int8_t -128..127; Значение 127 и < 0 - специальные значения для перехода по циклу эффектов

String  nameFiles[MAX_FILES];               // Список имен файлов, найденных в папке на SD-карте
bool    isSdCardReady = false;              // Флаг - SD карта инициализирована корректно
bool    play_file_finished = false;         // Флаг - воспроизведение эффекта завершено
bool    wait_play_finished = (WAIT_PLAY_FINISHED == 1);     // Флаг - true - переключаться на следующий эффект только когда весь файл показан; false - прерывать показ по истечении времени эффекта
uint8_t countFiles = 0;                     // Количество найденных файлов эффектов, найденных на SD-карте
int8_t  sf_file_idx = -1;                   // Эффект, проигрываемый с SD-карты - индекс в массиве nameFiles

#endif

// ************************* ПРОЧИЕ ПЕРЕМЕННЫЕ *************************

byte fadeMode = 4;                          // Фаза режима плавной смены эффекта
boolean modeDir;                            // Направление перехода к следующему / предыдущему режиму

// ---------------------------------------------------------------

#define  D_GAME_SPEED        150            // скорость игр по умолчанию (мс)
#define  D_EFFECT_SPEED       80            // скорость эффектов по умолчанию (мс)
#define  D_EFFECT_SPEED_MIN    0            // пределы регулировки скорости
#define  D_EFFECT_SPEED_MAX  255

// ---------------------------------------------------------------

#define  AUTOPLAY_PERIOD      60            // время между авто сменой режимов (секунды)
#define  IDLE_TIME            30            // время бездействия (в минутах, по умолчанию) после которого запускается автосмена режимов, если разрешена в настройках
#define  SMOOTH_CHANGE         0            // плавная смена режимов через чёрный

// ---------------------------------------------------------------

bool     eepromModified = false;            // флаг: EEPROM изменен, требует сохранения

// ---------------------------------------------------------------

uint32_t globalColor      = 0xffffff;       // цвет панели в режиме "Лампа" по умолчанию
uint32_t globalClockColor = 0xffffff;       // цвет часов в режиме MC_COLOR - режим цвета "Монохром" по умолчанию
uint32_t globalTextColor  = 0xffffff;       // цвет бегущей строки MC_TEXT в режиме цвета "Монохром" по умолчанию

uint32_t drawColor        = 0xffffff;       // цвет рисования
bool     sendImageFlag    = false;          // флаг: режим отправки изображения с матрицы в приложение на телефоне
byte     sendImageRow     = 0;              // Индекс отправляемого изображения (по строкам)
byte     sendImageCol     = 0;              // Индекс отправляемого изображения (по колонкам)
eSources sendImageSrc     = NONE;           // Источник запроса изображения

// ---------------------------------------------------------------

bool     specialMode = false;               // Спец.режим, включенный вручную со смартфона или с кнопок быстрого включения режима
bool     specialClock = false;              // Отображение часов в спец.режиме - как отдельный эффект "Часы" на черном фоне, а не как оверлей поверх других эффектов
byte     specialBrightness = 1;             // Яркость в спец.режиме

bool     isTurnedOff = false;               // Включен черный экран (т.е всё выключено) 
bool     isNightClock = false;              // Включен режим ночных часов

int8_t   specialModeId = -1;                // Номер текущего спецрежима
int8_t   manualModeId = -1;                 // Номер текущего режима

bool     useRandomSequence = true;          // Флаг: случайный выбор режима
bool     clockOverlayEnabled = true;        // Доступность оверлея часов поверх эффектов
bool     textOverlayEnabled = true;         // Доступность оверлея бегущей строки поверх эффектов
bool     overlayDelayed = false;            // используется для указания был ли оверлей на предыдущем цикле отрисовки
int8_t   y_overlay_low  = 0;                // Вычисленная позиция оверлея матрицы - во всю ширину, область отображения текста бегущей строки / часов / календаря
int8_t   y_overlay_high = 0;

int8_t   debug_hours = -1;                  // Для отладки позиционирования часов
int8_t   debug_mins = -1;                   // Для отладки позиционирования часов
int8_t   debug_temperature;                 // Для отладки позиционирования часов

// ---------------------------------------------------------------

// Сервер не может инициировать отправку сообщения клиенту - только в ответ на запрос клиента
// Следующие две переменные хранят сообщения, формируемые по инициативе сервера и отправляются в ответ на ближайший запрос от клиента,
// например в ответ на периодический ping - в команде sendAcknowledge();

String   cmd95 = "";                        // Строка, формируемая sendPageParams(95) для отправки по инициативе сервера
String   cmd96 = "";                        // Строка, формируемая sendPageParams(96) для отправки по инициативе сервера

// ---------------------------------------------------------------

byte     globalBrightness = BRIGHTNESS;     // текущая яркость бегущей строки и часов (общая)
byte     contrast = 255;                    // контрастность эффектов по отношению к яркости часов / бегущей строки (общей яркости) => 0.255 -> 10..100%
bool     brightDirection = false;           // true - увеличение яркости; false - уменьшение яркости при регулировке кнопкой

// ---------------------------------------------------------------

int      effectSpeed = D_EFFECT_SPEED;      // скорость изменения эффекта (по умолчанию)
byte     effectScaleParam[MAX_EFFECT];      // Динамический параметр эффекта, параметр #1
byte     effectScaleParam2[MAX_EFFECT];     // Динамический параметр эффекта, параметр #2
byte     effectContrast[MAX_EFFECT];        // Динамический параметр эффекта - контрастность (яркость эффекта относительно яркости часов или текста бегущей строки)
bool     manualMode = false;                // флаг: true - ручное управление эффектами; false - в режиме Autoplay
bool     loadingFlag = true;                // флаг: инициализация параметров эффекта

// ---------------------------------------------------------------

uint32_t idleTime = ((long)IDLE_TIME * 60 * 1000L);     // минуты -> миллисек
uint32_t autoplayTime = ((long)AUTOPLAY_PERIOD * 1000L);// секунды -> миллисек
bool     idleState = true;                              // флаг холостого режима работы
uint32_t autoplayTimer;                                 // время до автоматического перехода в демо-режим
uint32_t upTime = 0;                                    // время работы системы с последней перезагрузки

// ---------------------------------------------------------------

int8_t   thisMode = 0;                      // текущий режим - id
String   effect_name = "";                  // текущий режим - название

// ---------------------------------------------------------------

#define  GLOBAL_COLOR_1 CRGB::Green         // основной цвет №1 для игр
#define  GLOBAL_COLOR_2 CRGB::Orange        // основной цвет №2 для игр
#define  SCORE_SIZE 1                       // размер символов счёта в игре. 0 - маленький для 8х8 (шрифт 3х5), 1 - большой (шрифт 5х7)

boolean  gameDemo = true;                   // Игры Тетрис, Лабиринт, Змейка работают в демо-режиме
boolean  gamePaused = false;                // Игра на паузе (при ручном управлении игрой) 
byte     buttons;                           // Эмуляция кнопок управления играми в демо-режиме

// ---------------------------------------------------------------
timerMinim gameTimer(D_GAME_SPEED);         // Таймер скорости игр
timerMinim effectTimer(D_EFFECT_SPEED);     // Таймер скорости эффекта (шага выполнения эффекта)
timerMinim clockTimer(D_CLOCK_SPEED);       // Таймер смещения оверлея часов
timerMinim textTimer(D_TEXT_SPEED);         // Таймер смещения оверлея часов
timerMinim changeTimer(70);                 // Таймер шага плавной смены режима - Fade
timerMinim halfsecTimer(500);               // Полусекундный таймер точек часов
timerMinim idleTimer(idleTime);             // Таймер бездействия ручного управления для автоперехода в демо-режим 
timerMinim dawnTimer(1000);                 // Таймер шага рассвета для будильника "рассвет" 
timerMinim alarmSoundTimer(4294967295);     // Таймер выключения звука будильника
timerMinim fadeSoundTimer(4294967295);      // Таймер плавного включения / выключения звука
timerMinim saveSettingsTimer(15000);        // Таймер отложенного сохранения настроек
timerMinim ntpSyncTimer(1000 * 60 * SYNC_TIME_PERIOD);    // Сверяем время с NTP-сервером через SYNC_TIME_PERIOD минут
#if (USE_WEATHER == 1)
timerMinim weatherTimer(1000 * 60 * SYNC_WEATHER_PERIOD); // Получаем текущую погоду каждые SYNC_WEATHER_PERIOD минут
#endif
// ********************* ДЛЯ ПАРСЕРА КОМАНДНЫХ ПАКЕТОВ *************************

#define    BUF_MAX_SIZE  4096               // максимальный размер выделяемого буфера для коммуникации по UDP каналу
#define    PARSE_AMOUNT  16                 // максимальное количество значений в массиве, который хотим получить
#define    header '$'                       // стартовый символ управляющей посылки
#define    divider ' '                      // разделительный символ
#define    ending ';'                       // завершающий символ
 
int32_t    intData[PARSE_AMOUNT];           // массив численных значений после парсинга - для WiFi часы время синхр м.б отрицательным + 
                                            // период синхронизации м.б больше 255 мин - нужен тип int32_t
char       incomeBuffer[BUF_MAX_SIZE];      // Буфер для приема строки команды из wifi udp сокета; также используется для загрузки строк из EEPROM
char       replyBuffer[8];                  // ответ клиенту - подтверждения получения команды: "ack;/r/n/0"

byte       ackCounter = 0;                  // счетчик отправляемых ответов для создания уникальности номера ответа

#if (USE_MQTT == 1)
#define    BUF_MQTT_SIZE  384               // максимальный размер выделяемого буфера для входящих сообщений по MQTT каналу
char       incomeMqttBuffer[BUF_MQTT_SIZE]; // Буфер для приема строки команды из MQTT
#endif

// --------------- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ ПАРСЕРА ------------------

uint32_t   prevColor;
boolean    recievedFlag;                               // буфер содержит принятые данные
boolean    parseStarted;
byte       parse_index;
String     string_convert = "";
String     receiveText = "";
bool       haveIncomeData = false;
char       incomingByte;

int16_t    bufIdx = 0;                                 // Могут приниматься пакеты > 255 байт - тип int16_t
int16_t    packetSize = 0;

// ************************* УПРАВЛЕНИЕ МАТРИЦЕЙ *******************************
String     host_name = "";                       // Имя для регистрации в сети
uint16_t   CURRENT_LIMIT = 10000;                // лимит по току в миллиамперах, автоматически управляет яркостью (пожалей свой блок питания!) 0 - выключить лимит

#define    NUM_LEDS              WIDTH * HEIGHT
#define    maxDim                max(WIDTH, HEIGHT)
#define    minDim                min(WIDTH, HEIGHT)

#if (HEIGHT < 17)
#define    OVERLAY_SIZE          WIDTH * HEIGHT   
#else
#define    OVERLAY_SIZE          WIDTH * 17       // 17 - максимальная высота области оверлея - для верт больших часов и календаря - две строки шрифта 5x7 + 2 строки пробела между
#endif

CRGBArray<NUM_LEDS> leds;                        // обращение к светодиодам матрицы через этот массив
CRGBArray<OVERLAY_SIZE> overlayLEDs;             // буфер оверлея; по максимуму - для бегущей строки во всю ширину матрицы или отображение календаря / вертикальных часов - 11 высота

#define    POWER_ON              HIGH            // Для включения питания матрицы (через MOSFET) подавать на пин POWER_PIN высокий уровень
#define    POWER_OFF             LOW             // Для вЫключения питания матрицы (через MOSFET) подавать на пин POWER_PIN низкий уровень

#define    TRUE_RANDOM

// *****************************************************************************
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************

// ------------------- ФАЙЛОВАЯ СИСТЕМА SPIFFS ----------------------

bool       spiffs_ok = false;                    // Флаг - файловая система SPIFFS доступна для использования
size_t     spiffs_total_bytes;                   // Доступно байт в SPIFFS
size_t     spiffs_used_bytes;                    // Использовано байт в SPIFFS
int8_t     eeprom_backup = 0;                    // Флаг - backup настроек 0 - нeт; 1 - FS; 2 - SD; 3 - FS и SD

// ------------------- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ ----------------------

bool       saveSpecialMode = specialMode;
int8_t     saveSpecialModeId = specialModeId;
byte       saveMode;
byte       tmpSaveMode = 0;

// ---------------------------------------------------------------
